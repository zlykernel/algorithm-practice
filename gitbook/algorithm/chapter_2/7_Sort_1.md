### **需求/现实应用**

+ 如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？


### **原理/理论**
   + 类型     :
```
归并排序 （Merge Sort）:
   思想 
      归并排序使用的就是分治思想

   实现
      中间节点即1/2位置

   性能分析
      第一，归并排序是稳定的排序算法吗？
         归并排序是一个稳定的排序算法。
      第二，归并排序的时间复杂度是多少？
         最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。
      第三，归并排序的空间复杂度是多少？
         O(n)
      第四，非原地排序算法
         主要原因是合并函数无法在原地执行

归并排序的原理如图:
```
![归并排序](../image/img2-7-1.jpg)

```
快速排序算法 （Quicksort）：
   思想：
      如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。

   实现
      找到1/2
      
   性能分析
      第一，归并排序是稳定的排序算法吗？
         归并排序是一个稳定的排序算法。
      第二，归并排序的时间复杂度是多少？
         最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。
      第三，归并排序的空间复杂度是多少？
         O(n)
      第四，原地排序算法
         使用原地分区函数,解决了归并排序占用太多内存的问题。
```
![快速排序](../image/img2-7-1.jpg)

### **思考/总结/扩展**
+ 思考

```
1.现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？

答案:

```

+ 总结

```
1.分治是一种解决问题的处理思想，递归是一种编程技巧
2.不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。
3.归并排序的处理过程是由下到上的，先处理子问题，然后再合并。
而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。
```
![区别](../image/img2-7-2.jpg)
### **实践/测试**
+ [归并排序](/src/main/java/com/zlykernel/pratice/algorithm/sort/SortSecond.java)
+ [快速排序算法](/src/main/java/com/zlykernel/pratice/algorithm/sort/SortSecond.java)
