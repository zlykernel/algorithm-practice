### **需求/现实应用**

+ 如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？


### **原理/理论**
   + 类型     :
```
归并排序 （Merge Sort）:
   原理 
      归并排序使用的就是分治思想

   推导过程
      递推公式：
      merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))
      终止条件：
      p >= r 不用再继续分解
      解释:
      merge_sort(p…r) 表示，给下标从 p 到 r 之间的数组排序。我们将这个排序问题转化为了两个子问题，merge_sort(p…q) 和 merge_sort(q+1…r)，其中下标 q 等于 p 和 r 的中间位置，也就是 (p+r)/2。当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据就也排好序了。

   性能分析
      第一，归并排序是稳定的排序算法吗？
         归并排序是一个稳定的排序算法。
      第二，归并排序的时间复杂度是多少？
         最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。
      第三，归并排序的空间复杂度是多少？
         O(n)
      第四，非原地排序算法
         主要原因是合并函数无法在原地执行

归并排序的原理如图:
```
![归并排序](../image/img2-7-1.jpg)

```
快速排序 （Quicksort）：
   原理
      如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。

   推导过程  
      递推公式：
      quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)
      终止条件：
      p >= r
      解释:
      遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。
      
   性能分析
      第一，归并排序是稳定的排序算法吗？
         归并排序是一个稳定的排序算法。
      第二，归并排序的时间复杂度是多少？
         最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。
      第三，归并排序的空间复杂度是多少？
         O(n)
      第四，原地排序算法
         使用原地分区函数,解决了归并排序占用太多内存的问题。
```
![快速排序](../image/img2-7-1.jpg)

### **思考/总结/扩展**
+ 思考

```
1.现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？

答案:

2.优缺点:
归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此，它也没有快排应用广泛。
```

+ 总结

```
1.分治是一种解决问题的处理思想，递归是一种编程技巧
2.不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。
3.归并排序的处理过程是由下到上的，先处理子问题，然后再合并。
而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。
```
![区别](../image/img2-7-2.jpg)
### **实践/测试**
+ [归并排序](/src/main/java/com/zlykernel/pratice/algorithm/sort/SortSecond.java)
+ [快速排序算法](/src/main/java/com/zlykernel/pratice/algorithm/sort/SortSecond.java)
