**需求/现实应用**
   
   + 队列在线程池等有有限资源池中的应用
   + Linux环形缓存，使用循环并发队列
   + 高性能队列Disruptor，使用循环并发队列
   + Java concurrent并发包利用ArrayBlockingQueue来实现公平锁
   
**原理/理论**
   + 模型抽象 : 入列(enqueue) 和 出列(dequeue)
   + 类型
   ```
基础队列:
    顺序队列
    链式队列
变种队列:
    循环队列
    阻塞队列
    并发队列
   ``` 
   + 复杂度分析
```
    时间复杂度:
        最好时间复杂度:正常情况入列和出列为O(1)
        最坏时间复杂度:当发生数据搬移时为O(n)
        均摊时间复杂度:为O(n)/n = O(1)

    空间复杂度:
        入列和出列不需要额外空间为O(1)

```

   
**思考/总结**

   + 总结
```
1.队列使用场景:当资源有限的时候，来实现请求队列化。

2.数组和链表是基础数据结果，其他结构可以基于此两种结构，数组需要考虑扩容问题。

3.无锁化一般使用cas:java中的应用JUC;cas的原理Linux的X86下主要是通过cmpxchgl这个指令在CPU级完成CAS操作的，但在多处理器情况下必须使用lock指令加锁来完成;问题ABA问题，JAVA中提供了AtomicStampedReference/AtomicMarkableReference来处理会发生ABA问题的场景，主要是在对象中额外再增加一个标记来标识对象是否有过变更。

4.实现队列时主要是，双指针的临界判断，影响到扩容及循环队列。
```
   + 思考
```
1.除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢？

答案:分布式消息队列 kafka

2.如何实现无锁并发队列

答案: cas + 数组的方式

```
**实践/测试**

+ [顺序队列]()
+ [链式队列]()
+ [循环队列]()
+ [阻塞队列]()
+ [并发队列]()
+ [使用CAS实现无锁队列]()
