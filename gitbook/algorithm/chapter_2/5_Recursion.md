### **需求/现实应用**
+ 推荐注册返佣金，找到最终的推荐人
+ DFS深度优先搜索
+ 前中后二叉树

### **原理/理论**
   + 模型抽象 :
```
1.方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归
```
   + 类型     :
```
f(n) = f(n-1) + 1;
f(n) = f(n-1) + f(n-2);
f(n)=n*f(n-1);
```
   + 复杂度分析:

```
时间复杂度：O(n)
空间复杂度：o(n),每一次调用的时候就会在内存栈中保存一次。需要额外考虑这一部分的空间消耗。
```
   
### **思考/总结/扩展**
+ 思考

```
1.对于规模比较大递归层次很深的递归代码，无法使用IDE单步跟踪进行调试时，如何进行调试
答案 ： 1.打印日志发现递归值 2.结合条件断点进行调试。

2.优缺点
答案：优点：代码简洁，表现力强大
      缺点：比较难理解，空间复杂度高，有堆栈溢出风险，存在重复计算，过多的函数调用会耗时比较多。

3.递归什么时候会出现堆栈溢出及死循环，如何避免。
答案：1.原因：当没有递归终止条件的时候；当递归过程中，递归
2.解决方案：通过限制递归深度；针对死循环可以使用自动检查环

4.递归时会出现重复计算，如何解决？
答案：1.f(n) = f(n-1) + f(n-2);return 多个子问题时。
2.解决方案：通过数据结果比如散列表来保存已经求过解f(k)
```
+ 总结

```
1.编写递归公式代码
写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。
递推公司

2.循环和递归
计算机擅长做重复的事情比如循环和递归。二者均可以自动重复的进行知道解决问题，应该避免死循环。

3.避免递归思考误区
如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。

```

### **实践/测试**
+ [上台阶:假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？]()
+ [递归的深度]()
+ [重复计算]()

