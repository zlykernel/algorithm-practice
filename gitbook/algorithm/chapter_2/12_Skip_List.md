### **需求/现实应用**
+ Redis 中的有序集合（Sorted Set）就是用跳表来实现的.


### **原理/理论**
   + 模型抽象 : 原始链表 + 索引层
```
     原理:即链表加多级索引的结构，就是跳表;
     推到过程:查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。
     复杂度分析(性能分析):
         时间复杂度:O(m*logn)： 每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2k)。
         空间复杂度:
       
```
![](../image/img2-12-1.jpg)

### **思考/总结/扩展**
+ 总结
```
   1.跳表基于单链表实现了二分查找
   2.跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。
```

+ 扩展
```
1.Redis的对象系统中的每种对象实际上都是基于使用场景选择多种底层数据结构实现的，比如ZSET就是基于【压缩列表】或者【跳跃表+字典】（这也跟之前排序中提到的Sort包实现的思想一样，基于数据规模选择合适的排序算法），体现了Redis对于性能极致的追求。
2.redis有序集合,复合数据结构，准确说应该是由一个双hashmap构成的字典和跳跃表实现的
```

### **实践/测试**
+ [跳表实现]()
+ [redis数据结构]()
