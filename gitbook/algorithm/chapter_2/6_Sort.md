### **需求/现实应用**
+ 学习的目的也只是为了开拓思维，实际开发中应用并不多
  


### **原理/理论**
   + 模型抽象 :

```
稳定性:如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。例子如图：
```
![](../image/img2-6-3.jpg)
```

有序度:是数组中具有有序关系的元素对的个数。
满有序度:完全有序的数组的有序度。
逆序度 = 满有序度 - 有序度。
```
   + 类型     :
```
冒泡排序（Bubble Sort）:
   冒泡排序包含两个操作原子，比较和交换。
```
![](../image/img2-6-2.jpg)
```
插入排序（Insertion Sort）：
   我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素
```
![](../image/img2-6-5.jpg)
```
选择排序（Selection Sort）:
   选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。
```
![](../image/img2-6-4.jpg)
   + 复杂度分析:

```
冒泡排序
   平均时间复杂度为 O(n2)
   最坏情况时间复杂度为 O(n2) :如果数组是倒序的。
   最好是时间复杂度为 O(n) :从尾到头遍历已经有序的数据。

插入排序
   平均时间复杂度为 O(n2)
   最坏情况时间复杂度为 O(n2) :如果数组是倒序的。
   最好是时间复杂度为 O(n) :从尾到头遍历已经有序的数据。

选择排序  
   空间复杂度为 O(1)
   最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)

```

   
### **思考/总结/扩展**
+ 思考

```
1.优缺点

2.插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？
答案:

3.排序算法，都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？
答案:有个前提，是否允许修改链表的节点value值，还是只能改变节点的位置。一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。
```

+ 总结
![](../image/img2-6-1.jpg)

### **实践/测试**
+ [冒泡排序(完成)](/src/main/java/com/zlykernel/pratice/algorithm/sort/Sort.java)
+ [插入排序(完成)](/src/main/java/com/zlykernel/pratice/algorithm/sort/Sort.java)
+ [选择排序(完成)](/src/main/java/com/zlykernel/pratice/algorithm/sort/Sort.java)
+ [希尔排序]()

